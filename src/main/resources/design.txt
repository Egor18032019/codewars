Реализуйте класс BSTIterator, представляющий итератор для упорядоченного обхода двоичного дерева поиска (BST):

BSTIterator(TreeNode root) Инициализирует объект класса BSTIterator.
Корень BST задается как часть конструктора.
Указатель должен быть инициализирован несуществующим числом, меньшим, чем любой элемент в BST.
boolean hasNext() Возвращает true, если существует число в обходе справа от указателя,
                  в противном случае возвращает false.
int next() Перемещает указатель вправо, затем возвращает число у указателя.

Обратите внимание, что при инициализации указателя несуществующим наименьшим числом первый вызов next()
вернет наименьший элемент в BST.

Вы можете предположить, что вызовы next() всегда будут действительны.
То есть будет по крайней мере следующее число в обходе по порядку, когда вызывается next().



Пример 1:

Вход
['BSTIterator', 'следующий', 'следующий', 'hasNext', 'следующий', 'hasNext', 'следующий', 'hasNext', 'следующий', 'hasNext']
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Выход
[ноль, 3, 7, правда, 9, правда, 15, правда, 20, ложь]

Объяснение
BSTIterator bSTIterator = новый BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.следующий(); // вернуть 3
bSTIterator.следующий(); // вернуть 7
bSTIterator.hasNext(); // вернуть Истина
bSTIterator.следующий(); // вернуть 9
bSTIterator.hasNext(); // вернуть Истина
bSTIterator.следующий(); // вернуть 15
bSTIterator.hasNext(); // вернуть Истина
bSTIterator.следующий(); // вернуть 20
bSTIterator.hasNext(); // вернуть ложь



Ограничения:

Количество узлов в дереве находится в диапазоне [1, 105].
0 = Node.val = 106
Будет сделано не более 105 вызовов hasNext и next.


 public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }